const { Client } = require('pg');
const sanitizer = require('sanitizer');

class DBQuery {
    constructor(data, success) {
        this.data = data
        this.success = success
    }
}

class Database {

    constructor(link, username, password, name, port) {
        this.link = link
        this.username = username
        this.password = password
        this.name = name
        this.port = port

        this.configCache = [];

        this.sql = new Client({
            user: this.username,
            host: this.link,
            database: this.name,
            password: this.password,
            port: this.port,
        });


        this.authState = 0;

        

        //  Server=${this.link},${this.port};Initial Catalog=${this.name};Persist Security Info=False;User ID=${this.username};Password=${this.password};MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
        //  Data Source=${this.link},${this.port};Network Library=DBMSSOCN;Initial Catalog=${this.name};User ID=${this.username};Password=${this.password};MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
        //mssql.connect(`Data Source=${this.link},${this.port};Network Library=DBMSSOCN;Initial Catalog=${this.name};User ID=${this.username};Password=${this.password};MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=True;Connection Timeout=30;`)

        this.setup();

    }

    async setup(){
        await this.sql.connect();
        await this.verifySchema();
        var required_config = process.env.REQUIRED_CONFIG.split(",")
            var default_values = process.env.REQUIRED_CONFIG_DEFAULT.split(",")

            var required_permissions = [];
        try{
            required_permissions = process.env.REQUIRED_PERMISSIONS.split(",");
        }catch(e){
            
        }
        

            for (var i = 0; i < required_config.length; i++) {
                // ensure that this_config will persist through the loop so that the correct value is used
                let j = i;
                let this_config_key = required_config[i];
                let this_config_value = default_values[i];
                this.getConfigProperty_uniq_name(required_config[i]).then((result) => {
                    if (result.data.length == 0) {
                        console.log("Creating required config " + result.uniq_name)
                        this.setConfig(this_config_key, this_config_key, this_config_value, -1, "string");
                    }
                });
                
            }

            for (var i = 0; i < required_permissions.length; i++) {
                // ensure that this_config will persist through the loop so that the correct value is used
                let j = i;
                let this_permission = required_permissions[i];
                this.getPermission(this_permission).then((result) => {
                    if (result.data.length == 0) {
                        console.log("Creating required permission " + result.permission_uniq_name)
                        this.setPermission(this_permission, this_permission);
                    }
                });
                
            }

    }

    async verifySchema(){
        /*

            ### Config

            * cid (primary) - int
            * name - string
            * value - string
            * updated - datetime
            * uid - string
            * type - string
            * uniq_name - string

        */

        // make sure to use POSTGRES syntax for this

        // create config table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS config (cid INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1000000 INCREMENT BY 1) PRIMARY KEY, name VARCHAR, value VARCHAR, updated TIMESTAMP, uid VARCHAR, type VARCHAR, uniq_name VARCHAR);")
        

        /*

            ### Identity Management

            * uid (primary) - int
            * full_name - string
            * rid - int
            * last_seen - datetime
            * mtu_based - bool
            * mtu_id - string
            * mtu_uid - string
            * email - string

        */

        // create identity_management table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS identity_management (uid INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1000000 INCREMENT BY 1) PRIMARY KEY, full_name VARCHAR, rid INT, last_seen TIMESTAMP, mtu_based BOOLEAN, mtu_id VARCHAR, mtu_uid VARCHAR, email VARCHAR)")

        /*

            ### Identity Holds

            * fuid (primary) - int
            * mtu_id - string
            * rid - int
            * created - datetime
            * by_uid - int
            * reason - string
            * expires - datetime

        */

        // create identity_management_holds table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS identity_management_holds (fuid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, mtu_id VARCHAR, rid INT, created TIMESTAMP, by_uid INT, reason VARCHAR, expires TIMESTAMP)")

        /*

            ### Alternate Authentication

            * uid (primary) - int
            * email - string
            * pwhash - string
            * pwsalt - string
            * pwiter - int
            
        */

        // create alternate_authentication table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS alternate_authentication (uid INT PRIMARY KEY, email VARCHAR, pwhash VARCHAR, pwsalt VARCHAR, pwiter INT)")

        /*

            ### Identity Management Groups

            * uid (primary) - int
            * gid (primary) - int
            * updated - datetime
            * elevated - boolean

        */

        // create identity_management_groups table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS identity_management_groups (uid INT, gid INT, updated TIMESTAMP, elevated BOOLEAN, PRIMARY KEY(uid, gid))")

        /*

            ### Identity Management Splits

            * uid (primary) - int
            * sid (primary) - int
            * updated - datetime
            * elevated - boolean

        */

        // create identity_management_splits table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS identity_management_splits (uid INT, sid INT, updated TIMESTAMP, elevated BOOLEAN, PRIMARY KEY(uid, sid))")

        /*

            ### Identity Management Roles

            * rid (primary) - int
            * name - string
            * power - int
            * updated - datetime
            * description - string

        */

        // create identity_management_roles table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS identity_management_roles (rid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR, power INT, updated TIMESTAMP, description VARCHAR)")

        /*
            ### Permissions

            - permission_uniq_name (primary) - string
            - description - string
        */

        // create permissions table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS permissions (permission_uniq_name VARCHAR PRIMARY KEY, description VARCHAR)")

        /*

            ### Role Permissions

            - rid (primary) - int
            - permission_uniq_name (primary) - string
            - granted - datetime

        */

        // create role_permissions table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS role_permissions (rid INT, permission_uniq_name VARCHAR, granted TIMESTAMP, PRIMARY KEY(rid, permission_uniq_name))")

        /*

            ### Event Types

            * etyid (primary) - int
            * name - string
            * icon - string
            * color - string
            * extra_data - string
            * updated - datetime

        */

        // create event_types table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS event_types (etyid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR, icon VARCHAR, color VARCHAR, extra_data VARCHAR, updated TIMESTAMP)")

        /*

            ### Event Templates

            * etid (primary) - int
            * etyid - int
            * name - string
            * data - string
            * updated - datetime

        */

        // create event_templates table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS event_templates (etid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, etyid INT, name VARCHAR, data VARCHAR, updated TIMESTAMP)")

        /*
        
            ### Event Splits

            * eid (primary) - int
            * sid (primary) - int
            * updated - datetime

        */

        // create event_splits table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS event_splits (eid INT, sid INT, updated TIMESTAMP, PRIMARY KEY(eid, sid))")

        /*
        
            ### Event Participation Exceptions

            * eid (primary) - int
            * uid (primary) - int
            * override - int

        */

        // create event_participation_overrides table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS event_participation_overrides (eid INT, uid INT, override INT, PRIMARY KEY(eid, uid))")

        /*

            ### Events

            * eid (primary) - int
            * etyid - int
            * etid_used - int
            * string - name
            * begin - datetime
            * end - datetime
            * open - boolean
            * show - boolean
            * data - string
            * updated - datetime
            * location - string
            * description - string

        */
        
        // create events table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS events (eid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, etyid INT, etid_used INT, name VARCHAR, start TIMESTAMP, ending TIMESTAMP, show BOOLEAN, data VARCHAR, updated TIMESTAMP, location VARCHAR, description VARCHAR)")

        /*

            ### Groups

            * gid (primary) - int
            * name - string
            * icon - string
            * description - string
            * open - boolean
            * extra_data - string
            * color - string

        */

        // create groups table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS groups (gid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR, icon VARCHAR, description VARCHAR, open BOOLEAN, extra_data VARCHAR, updated TIMESTAMP, color VARCHAR)")

        /*

            ### Splits

            * sid (primary) - int
            * gid - int
            * name - string
            * icon - string
            * updated - datetime
            * open - boolean
            * extra_data - string
            * color - string
            
        */

        // create splits table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS splits (sid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gid INT, name VARCHAR, icon VARCHAR, updated TIMESTAMP, open BOOLEAN, extra_data VARCHAR, color VARCHAR)")

        /*

            ### Announcements

            * aid (primary) - int
            * name - string
            * content - string
            * icon - string
            * uid - int
            * published - datetime
            * until - datetime
            * global - boolean
            * notified - boolean

        */

        // create announcements table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS announcements (aid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR, content VARCHAR, icon VARCHAR, uid INT, published TIMESTAMP, until TIMESTAMP, global BOOLEAN, notified BOOLEAN, related_event INT)")

        /*
            ### Announcement Splits

            - aid (primary) - int
            - sid (primary) - int
            - notify - boolean

        */

        // create announcement_splits table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS announcement_splits (aid INT, sid INT, notify BOOLEAN, PRIMARY KEY(aid, sid))")

        /*

            ### Announcement Groups

            - aid (primary) - int
            - gid (primary) - int
            - notify - boolean

        */

        // create announcement_groups table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS announcement_groups (aid INT, gid INT, notify BOOLEAN, PRIMARY KEY(aid, gid))")

        /*

            ### Songs

            * soid (primary) - int
            * name - string
            * friendly_name - string (for forms of abbreviation)
            * modification - string
            * artist - string
            * updated - datetime
            * duration - int
            * source - string
            * category - string

        */

        // create songs table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS songs (soid INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR, friendly_name VARCHAR, modification VARCHAR, artist VARCHAR, updated TIMESTAMP, duration INT, source VARCHAR, category VARCHAR)")

        /*

            ### Song Usage

            * soid (primary) - int
            * eid (primary) - int
            * count - int
            * used - datetime
            
        */

        // create song_usage table if it doesn't exist
        await this.query("CREATE TABLE IF NOT EXISTS song_usage (soid INT, eid INT, count INT, used TIMESTAMP, PRIMARY KEY(soid, eid))")
    }

    query(base, args) {
        if(!args){
            args = []
        }
        return new Promise(async (resolve, reject) => {

            /*

            Returning object looks like: 
                
                {
                    data: [<rows>],
                    success: true
                }
                
                or

                {
                    data: null,
                    success: false
                }

            */
            try{
                let result = await this.sql.query(base, args)

                let data = result.rows
                resolve(new DBQuery(data, true))
            }catch(e){
                resolve(new DBQuery(null, false))
            }
        })
    }
}


const DBInstance = new Database(process.env.DB_LINK, process.env.DB_USER, process.env.DB_PASS, process.env.DB_NAME, process.env.DB_PORT);

const exportObject = {
    // pass the database object to the export object
    Database: DBInstance,

    // pass back a set of queries relating to identity management
    identity: {

        // .identity.checkAccess(role, permission_name)

        // .identity.getIdentities()
            // returns all identities, but permissions must be checked separately in API
        getIdentities: async () => {
            return (await DBInstance.query("SELECT * FROM identity_management"))
        },

        // .identity.getIdentity_mtusso(mtu_id)
            // returns the identity based on their Michigan Tech username
        getIdentity_mtusso: async (mtu_id) => {
            return (await DBInstance.query("SELECT * FROM identity_management WHERE mtu_id = $1", [mtu_id]))
        },

        // .identity.getIdentity_mtuuid(mtu_uid)
            // returns the identity based on their Michigan Tech unique ID (different from their username)
        getIdentity_mtuuid: async (mtu_uid) => {
            return (await DBInstance.query("SELECT * FROM identity_management WHERE mtu_uid = $1", [mtu_uid]))
        },

        // .identity.getIdentity_uid(uid)
            // returns the identity based on their Pep Band ID
        getIdentity_uid: async (uid) => {
            return (await DBInstance.query("SELECT * FROM identity_management WHERE uid = $1", [uid]))
        },

        // .identity.getIdentityRole(uid)
            // returns the role of the identity
        getIdentityRole: async (uid) => {
            return (await DBInstance.query("SELECT rid FROM identity_management WHERE uid = $1", [uid]))
        },

        // .identity.getIdentityGroups(uid)
            // returns the groups that the identity is a part of
        getIdentityGroups: async (uid) => {
            return (await DBInstance.query("SELECT gid FROM identity_management_groups WHERE uid = $1", [uid]))
        },

        // .identity.getIdentitySplits(uid)
            // returns the splits that the identity is a part of
        getIdentitySplits: async (uid) => {
            return (await DBInstance.query("SELECT sid FROM identity_management_splits WHERE uid = $1", [uid]))
        },

        // .identity.deleteIdentity_uid(uid)
            // deletes the identity based on their Pep Band ID
        deleteIdentity_uid: async (uid) => {
            return (await DBInstance.query("DELETE FROM identity_management WHERE uid = $1", [uid]))
        },

        // .identity.deleteIdentity_mtusso(mtu_id)
            // deletes the identity based on their Michigan Tech username
        deleteIdentity_mtusso: async (mtu_id) => {
            return (await DBInstance.query("DELETE FROM identity_management WHERE mtu_id = $1", [mtu_id]))
        },

        // all of the internal identity management functions are below (inside of Michigan Tech CAS)
        internal: {
            
            // .identity.internal.login(full_name, mtu_id, mtu_uid, email)
                // handles a login event from a Michigan Tech user
                // need to check if the user exists first
                // return their entire identity object
            login: async (full_name, mtu_id, mtu_uid, email) => {
                // use the getIdentity_mtusso function to check if the user exists
                let user = await exportObject.identity.getIdentity_mtusso(mtu_id);

                // if the user doesn't exist, create them
                // make sure to set the mtu_based flag to true
                if(user.data == null || user.data.length == 0){
                    // create the user
                    let new_user = await DBInstance.query("INSERT INTO identity_management (full_name, mtu_id, mtu_uid, email, mtu_based) VALUES ($1, $2, $3, $4, true) RETURNING *", [full_name, mtu_id, mtu_uid, email])
                    return new_user;
                }

                // set last_seen property of user to now
                let updated_user = await DBInstance.query("UPDATE identity_management SET last_seen = NOW() WHERE mtu_id = $1 RETURNING *", [mtu_id])
                return updated_user;
               
            },



        },

        external: {

            // .identity.external.register(full_name, email, pwhash, pwsalt, pwiter)
                // handles a registration event from an external user
                // first insert into identity_management as a non-Michigan Tech user
                // then insert into alternate_authentication
            register: async (full_name, email, pwhash, pwsalt, pwiter) => {
                // create the user
                // set the mtu_id and mtu_uid to the email when creating the user
                let new_user = await DBInstance.query("INSERT INTO identity_management (full_name, email, mtu_based, mtu_id, mtu_uid) VALUES ($1, $2, false, $3, $4) RETURNING *", [full_name, email, email, email])

                // create the alternate authentication
                let new_auth = await DBInstance.query("INSERT INTO alternate_authentication (uid, email, pwhash, pwsalt, pwiter) VALUES ($1, $2, $3, $4, $5) RETURNING *", [new_user.data[0].uid, email, pwhash, pwsalt, pwiter])

                return new_user;
            },

            // .identity.external.getAlternateIdentity_uid(uid)
                // returns the alternate authentication based on the user's Pep Band ID
            getAlternateIdentity_uid: async (uid) => {
                return (await DBInstance.query("SELECT * FROM alternate_authentication WHERE uid = $1", [uid]))
            },

            // .identity.external.getAlternateIdentity_email(email)
                // returns the alternate authentication based on the user's email
            getAlternateIdentity_email: async (email) => {
                return (await DBInstance.query("SELECT * FROM alternate_authentication WHERE email = $1", [email]))
            },

            setAlternateIdentitySeen: async (uid) => {
                return (await DBInstance.query("UPDATE alternate_authentication SET last_seen = NOW() WHERE uid = $1", [uid]))
            }
        }
    },

    permissions: {
        // .permissions.getPermission(permission_name)
            // returns the permission based on the permission name
        getPermission: async (permission_name) => {
            return (await DBInstance.query("SELECT * FROM permissions WHERE permission_uniq_name = $1", [permission_name]))
        },

        // .permissions.getPermissions()
            // returns all permissions
        getPermissions: async () => {
            return (await DBInstance.query("SELECT * FROM permissions"))
        },

        // .permissions.setPermission(permission_name, description)
            // sets the permission based on the permission name
            // if it doesn't exist, create it
        setPermission: async (permission_name, description) => {
            let permission = await exportObject.permissions.getPermission(permission_name);
            if(permission.data == null || permission.data.length == 0){
                return (await DBInstance.query("INSERT INTO permissions (permission_uniq_name, description) VALUES ($1, $2) RETURNING *", [permission_name, description]))
            }
            // update the permission with the new description
            return (await DBInstance.query("UPDATE permissions SET description = $1 WHERE permission_uniq_name = $2 RETURNING *", [description, permission_name]))
        },

        deletePermission: async (permission_name) => {
            return (await DBInstance.query("DELETE FROM permissions WHERE permission_uniq_name = $1", [permission_name]));
        },

        
    }


}

module.exports = Database